import { NextResponse } from 'next/server';
import { getSupabase } from '@/lib/supabase';
import { eventsStore, genCode, EventItem, EventStatus } from '@/lib/eventsStore';

// store & genCode ora centralizzati

function requireDJSecret(req: Request) {
  const secret = process.env.DJ_PANEL_SECRET?.trim();
  const user = process.env.DJ_PANEL_USER?.trim();
  if (!secret || !user) return 'misconfigured';
  const hSecret = req.headers.get('x-dj-secret')?.trim();
  const hUser = req.headers.get('x-dj-user')?.trim();
  if (hSecret !== secret || hUser !== user) return 'unauthorized';
  return null;
}

const BUILD_TAG = 'events-omit-active-v1';

function withVersion<T>(data: T, init?: { status?: number; headers?: HeadersInit }) {
  const baseHeaders: Record<string, string> = { 'X-App-Version': BUILD_TAG };
  if (init?.headers) {
    if (Array.isArray(init.headers)) {
      for (const [k, v] of init.headers) baseHeaders[k] = v as string;
    } else if (init.headers instanceof Headers) {
      init.headers.forEach((v, k) => { baseHeaders[k] = v; });
    } else {
      Object.assign(baseHeaders, init.headers as Record<string, string>);
    }
  }
  return NextResponse.json(data, { status: init?.status, headers: baseHeaders });
}

export async function GET(req: Request) {
  const authErr = requireDJSecret(req);
  if (authErr) return withVersion({ ok: false, error: authErr }, { status: authErr === 'misconfigured' ? 500 : 401 });
  const url = new URL(req.url);
  const active = url.searchParams.get('active');
  const supabase = getSupabase();
  if (supabase) {
    let q = supabase.from('events').select('*').order('created_at', { ascending: false });
    if (active != null) q = q.eq('active', active === 'true');
    const { data, error } = await q;
    if (error) return withVersion({ ok: false, error: error.message }, { status: 500 });
    return withVersion({ ok: true, events: data || [] });
  }
  let list = eventsStore;
  if (active != null) list = list.filter((e) => Boolean(e.active) === (active === 'true'));
  return withVersion({ ok: true, events: list });
}

export async function POST(req: Request) {
  const authErr = requireDJSecret(req);
  if (authErr) return withVersion({ ok: false, error: authErr }, { status: authErr === 'misconfigured' ? 500 : 401 });
  const body = (await req.json()) as Partial<EventItem> & { name?: string; code?: string; status?: EventStatus };
  const name = (body.name || '').trim();
  let code = (body.code || '').trim().toUpperCase();
  if (!name) return withVersion({ ok: false, error: 'invalid_name' }, { status: 400 });
  const autoGenerated = !code; // se l'utente ha lasciato vuoto il campo
  if (!code) code = genCode();
  const now = new Date().toISOString();
  const supabase = getSupabase();
  if (supabase) {
    // Retry loop solo se il codice era auto-generato (campo lasciato vuoto)
    const tried = new Set<string>();
  const maxAttempts = autoGenerated ? 6 : 1;
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      if (attempt > 0 && autoGenerated) {
        // rigenera (dopo 3 tentativi aumenta lunghezza per ridurre collisioni estreme)
        code = genCode(attempt >= 3 ? 6 : 5);
      }
      if (tried.has(code)) continue; // evita loop se generazione restituisce uguale
      tried.add(code);
      console.log('[events][POST] attempt', { attempt: attempt + 1, code, autoGenerated });
      try {
        const { data, error } = await supabase
          .from('events')
          .insert({ code, name, created_at: now, status: 'active' })
          .select('*')
          .single();
        if (error) {
          interface PgErrorShape { message: string; details?: string | null; hint?: string | null; code?: string | null }
          const raw = error as unknown as Partial<PgErrorShape>;
          const errObj: PgErrorShape = {
            message: error.message,
            details: typeof raw.details === 'string' ? raw.details : null,
            hint: typeof raw.hint === 'string' ? raw.hint : null,
            code: typeof raw.code === 'string' ? raw.code : null
          };
          const isDup = /duplicate key|unique/i.test(errObj.message);
            if (isDup) {
              console.log('[events][POST] duplicate_code', { code, attempt: attempt + 1, autoGenerated });
            } else {
              console.log('[events][POST] insert_error', { code, attempt: attempt + 1, error: errObj.message, details: errObj.details, hint: errObj.hint });
            }
            if (isDup) {
              if (!autoGenerated) {
                return withVersion({ ok: false, error: 'duplicate_code' }, { status: 409 });
              }
              // se autoGenerated continua il loop
              continue;
            }
          // altri errori: includiamo dettagli per diagnosi
          return withVersion({ ok: false, error: errObj.message, details: { code: errObj.code, hint: errObj.hint, details: errObj.details } }, { status: 500 });
        }
        console.log('[events][POST] success', { code, attempt: attempt + 1, autoGenerated });
  return withVersion({ ok: true, event: data, generated: autoGenerated, attemptCount: attempt + 1 });
      } catch (e: unknown) {
        const message = e instanceof Error ? e.message : String(e);
        console.log('[events][POST] runtime_error', { code, attempt: attempt + 1, message });
        // errore runtime non legato a duplicate: interrompiamo
        return withVersion({ ok: false, error: message }, { status: 500 });
      }
    }
    // Se esauriti i tentativi (caso estremamente improbabile) restituiamo duplicate_code + lista tentativi
    console.log('[events][POST] exhausted_attempts', { attempts: Array.from(tried) });
    return withVersion({ ok: false, error: 'duplicate_code', attempts: Array.from(tried), generated: autoGenerated, attemptCount: tried.size }, { status: 409 });
  }
  // Fallback in-memory con la stessa logica di retry se autoGenerated
  const tried = new Set<string>();
  const maxAttempts = autoGenerated ? 6 : 1;
  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    if (attempt > 0 && autoGenerated) {
      code = genCode(attempt >= 3 ? 6 : 5);
    }
    if (tried.has(code)) continue;
    tried.add(code);
    console.log('[events][POST][memory] attempt', { attempt: attempt + 1, code, autoGenerated });
    if (eventsStore.some((e) => e.code === code)) {
      if (!autoGenerated) {
        console.log('[events][POST][memory] duplicate_code', { code, attempt: attempt + 1 });
        return withVersion({ ok: false, error: 'duplicate_code' }, { status: 409 });
      }
      continue; // riprova
    }
    const item: EventItem = { id: `${Date.now()}`, code, name, created_at: now, status: 'active', active: true };
    eventsStore.unshift(item);
    console.log('[events][POST][memory] success', { code, attempt: attempt + 1 });
    return withVersion({ ok: true, event: item, generated: autoGenerated, attemptCount: attempt + 1 });
  }
  console.log('[events][POST][memory] exhausted_attempts', { attempts: Array.from(tried) });
  return withVersion({ ok: false, error: 'duplicate_code', attempts: Array.from(tried), generated: autoGenerated, attemptCount: tried.size }, { status: 409 });
}

export async function PATCH(req: Request) {
  const authErr = requireDJSecret(req);
  if (authErr) return withVersion({ ok: false, error: authErr }, { status: authErr === 'misconfigured' ? 500 : 401 });
  const body = (await req.json()) as { id?: string; code?: string; active?: boolean; name?: string; status?: EventStatus };
  const supabase = getSupabase();
  if (supabase) {
  const patch: { /* active?: boolean; */ name?: string; status?: string } = {};
    if (typeof body.status === 'string') {
      patch.status = body.status; // active derivato lato UI
    }
    if (typeof body.active === 'boolean') {
      if (!patch.status) patch.status = body.active ? 'active' : 'paused'; // non scriviamo campo active in DB (legacy)
    }
    if (typeof body.name === 'string' && body.name.trim()) patch.name = body.name.trim();
    if (Object.keys(patch).length === 0) return withVersion({ ok: false, error: 'no_changes' }, { status: 400 });
  let q = supabase.from('events').update(patch);
    if (body.id) q = q.eq('id', body.id);
    else if (body.code) q = q.eq('code', body.code.toUpperCase());
    else return withVersion({ ok: false, error: 'invalid_identifier' }, { status: 400 });
    const { data, error } = await q.select('*').single();
    if (error || !data) return withVersion({ ok: false, error: error?.message || 'not_found' }, { status: 404 });
    return withVersion({ ok: true, event: data });
  }
  const idx = eventsStore.findIndex((e) => (body.id && e.id === body.id) || (body.code && e.code === body.code?.toUpperCase()));
  if (idx === -1) return withVersion({ ok: false, error: 'not_found' }, { status: 404 });
  const ev = eventsStore[idx];
  if (typeof body.status === 'string') {
    ev.status = body.status;
    ev.active = ev.status === 'active';
  }
  if (typeof body.active === 'boolean') {
    ev.active = body.active;
    ev.status = ev.active ? 'active' : (ev.status === 'closed' ? 'closed' : 'paused');
  }
  if (typeof body.name === 'string' && body.name.trim()) ev.name = body.name.trim();
  return withVersion({ ok: true, event: ev });
}

export async function DELETE(req: Request) {
  const authErr = requireDJSecret(req);
  if (authErr) return withVersion({ ok: false, error: authErr }, { status: authErr === 'misconfigured' ? 500 : 401 });
  const url = new URL(req.url);
  const id = url.searchParams.get('id')?.trim();
  const code = url.searchParams.get('code')?.trim().toUpperCase();
  if (!id && !code) return withVersion({ ok: false, error: 'missing_identifier' }, { status: 400 });
  const supabase = getSupabase();
  if (supabase) {
    // Recupera evento per avere code se manca
    let evCode = code;
    if (!evCode) {
      const { data: ev, error: e1 } = await supabase.from('events').select('code').eq('id', id).single();
      if (e1 || !ev) return withVersion({ ok: false, error: 'not_found' }, { status: 404 });
      evCode = ev.code;
    }
    // Elimina richieste collegate prima (se esistono)
    if (evCode) {
      await supabase.from('requests').delete().eq('event_code', evCode); // ignoriamo errore qui, non bloccante
    }
    let q = supabase.from('events').delete();
    if (id) q = q.eq('id', id);
    else if (evCode) q = q.eq('code', evCode);
    const { error: delErr } = await q;
    if (delErr) return withVersion({ ok: false, error: delErr.message }, { status: 500 });
    return withVersion({ ok: true, deleted: { id: id || null, code: evCode } });
  }
  // In-memory
  const idx = eventsStore.findIndex(e => (id && e.id === id) || (code && e.code === code));
  if (idx === -1) return withVersion({ ok: false, error: 'not_found' }, { status: 404 });
  const removed = eventsStore.splice(idx, 1)[0];
  return withVersion({ ok: true, deleted: { id: removed.id, code: removed.code } });
}
